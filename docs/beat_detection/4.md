Nice, you’re basically asking:

> “I can calculate the *correct BPM*, but my click is *shifted* vs. the drummer.
> How do I **align the phase** without ruining the metronome’s main job: being steady?”

That’s exactly a **tempo vs. phase** problem.
Smart solution: **separate those two** and treat them differently.

---

## 1. Separate tempo (T) and phase (offset)

Model the metronome beats as:

[
t_{\text{beat}}(n) = t_0 + n \cdot T
]

* (T) = beat period (seconds per beat) → **tempo**
* (t_0) = time of beat 0 → **phase / offset**

You want:

* **T** to change *very little* once locked (consistent click).
* **t₀** (or phase) to be corrected when you see an offset to the drummer.

So every new drum hit at time (t_k) gives you a **phase error**:

[
e_k = t_k - \hat{t}_{\text{beat}}(n_k)
]

where (\hat{t}_{\text{beat}}(n_k)) is your **predicted** closest beat time (or subdivision) to that hit.

---

## 2. Use a “PLL style” update: fast phase, slow tempo

This is the “smart but simple” version:

Keep state:

* `T`   – current beat period (from your BPM estimator)
* `phi` – current predicted beat time (phase), i.e. time of “now-beat”

On each hit at time `t`:

```c
float error = t - phi;     // phase error in seconds (how late/early the hit is)

// wrap the error into [-T/2, +T/2], so we don't jump by many beats
while (error >  0.5f * T) error -= T;
while (error < -0.5f * T) error += T;

// correction gains
float alpha = 0.2f;   // phase correction (bigger: faster align)
float beta  = 0.02f;  // tempo correction (smaller: stable tempo)

// update phase and tempo
phi += alpha * error;   // mostly phase shift
T   += beta  * error;   // tiny tempo correction

float bpm_est = 60.0f / T;
```

* **Phase (`phi`) moves quickly** → click “slides” into the drummer.
* **Tempo (`T`) moves slowly** → metronome stays steady, only gently adapts.

You can even set `beta = 0` if you want a *strict* fixed tempo and only allow the phase to slide.

---

## 3. Smart *one-time* alignment correction

If you don’t want the click to be constantly adjusting, do:

1. Collect a few hits (e.g. 1–2 bars).
2. Compute **best-fit tempo and offset** over that window.

   * You can do a simple linear regression on `(beat_index n, time t)` → gives slope (T) and intercept (t₀).
3. Set your metronome to that:

   * `T = slope`
   * `t0 = intercept` (or choose a nearby future beat to start the click).

Then **let it run free** with **no further phase corrections**, or only *very small* ones.

So the workflow:

* “Listening mode”: fit tempo + offset from drummer.
* “Playback mode”: free-running metronome using that tempo, minimal corrections.

---

## 4. Avoid ugly jumps: quantized phase corrections

You also don’t want the click to do tiny micro shifts each hit that the band hears as flammy. Two tricks:

### a) Only correct when error is big

```c
if (fabs(error) > 0.03f) { // > 30 ms
    phi += alpha * error;
}
```

Below some threshold, you just **ignore** the phase error.

### b) Shift by whole beats if really off

If your click drifted badly (e.g. ½ or 1 bar off):

```c
float beats_float = error / T;
int   beats_int   = (int)roundf(beats_float); // nearest integer beat shift
phi += beats_int * T;  // jump by whole beats
```

That way the click “jumps” by a whole number of beats instead of slow sliding across the bar.

---

## 5. Keep the metronome’s identity: consistency first

To stick to your requirement:

> main task of a metronome is keeping consistent

Design rules:

1. **Tempo changes are tiny and rare**

   * `beta` small
   * or tempo is fixed once set

2. **Phase corrections are either:**

   * small & smoothed (PLL style), or
   * occasional, quantized jumps (full beat/bar) when you decide to re-align.

3. Consider an **“alignment mode” vs “lock mode”**

   * In **alignment mode**, you allow some phase correction to lock into the drummer.
   * When confidence is high (tempo stable), switch to **lock mode** → no more phase changes, only display error.

---

If you tell me:

* do you prefer **“one-time lock then free-run”** or **“slowly following drummer”**,
* and which platform (ESP32 / C++ / C# / etc.),

I can write a concrete, drop-in code snippet for the exact behavior you want (with thresholds & gains picked for, say, 80–200 BPM rock tempos).

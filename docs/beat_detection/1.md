Given only a stream of unlabeled drum onsets (kick/snare/hh all mixed) and their inter-onset intervals (IOIs), the smartest tempo detector is:

**normalize IOIs to beat-scale candidates → vote/cluster → track with inertia (PLL/Kalman-lite).**

Here’s a clean, implementation-ready recipe.

---

## 1) Maintain a rolling IOI window

For each detected hit at time (t_k):

[
\text{IOI}*k = t_k - t*{k-1}
]

Keep last ~2–6 seconds of IOIs.

**Reject junk**:

* if IOI < 0.05–0.07 s → likely double-trigger/noise
* if IOI > 1.5–2.0 s → likely pause/fill gap

---

## 2) Interval normalization (folding)

Because hi-hat gives 8ths/16ths and snare gives backbeats, you must fold every IOI into a plausible BPM range.

For each IOI:

1. raw BPM:
   [
   bpm_0 = \frac{60}{IOI}
   ]

2. fold into range ([B_{min}, B_{max}]), e.g. 70–200 BPM:

```pseudo
bpm = bpm0
while bpm < 70:  bpm *= 2     # IOI was too long (multiple beats)
while bpm > 200: bpm /= 2     # IOI was too short (subdivision)
```

Now 16th/8th/quarter/half-note intervals all map to the same beat tempo.

---

## 3) Weighted tempo histogram / clustering

Create a histogram over BPM bins (1 BPM resolution is fine).

For each normalized bpm, add a vote with weight (w).

**Simple weight that downplays fast HH chatter:**
[
w = \min\left(1,\ \frac{IOI}{0.4\text{–}0.6s}\right)
]
So quarter-ish IOIs count most, 16ths count little.

Optionally blur histogram slightly (±1–2 BPM) so close candidates merge.

Peak bin → **tempo_peak**.

---

## 4) Track tempo over time (don’t jump)

Use a tracker so fills don’t derail tempo.

### Easiest stable smoother

```text
tempo_est = 0.9 * tempo_est + 0.1 * tempo_peak
```

### Better: tiny PLL (phase-locked loop)

Keep:

* (T) = seconds per beat (= 60/tempo)
* (\phi) = predicted next beat time

On each hit time (t):

```pseudo
error = t - phi
phi += alpha * error      # phase correction (alpha ~ 0.2)
T   += beta  * error      # tempo correction (beta ~ 0.01)
tempo_est = 60 / T
```

This “locks” to the groove and glides through messy sections.

---

## 5) Guard against 2× / ½× flips during fills

Two cheap rules:

1. **Subdivision cap**
   If IOI is much shorter than current beat period (T), reduce weight:
   [
   w \leftarrow w \cdot \exp\left(-\left(\frac{IOI}{T/2}\right)^2\right)
   ]

2. **Tempo inertia**
   Don’t allow tempo to change too fast unless confidence is high, e.g.:

* max ~6–8% per second change
* or clamp per update step.

---

## 6) Confidence score

Let:
[
conf = \frac{\text{peak height}}{\text{sum of histogram}}
]
(or peak/2nd-peak ratio)

Use it to:

* only publish tempo when conf > threshold
* freeze tempo updates when conf drops (fills)

---

### Why this is the smartest approach here

Because with unlabeled drum hits:

* you *cannot* assume each hit is a beat
* subdivisions/multiples are inevitable
* but IOIs still cluster around beat tempo once normalized
* tracking adds musical stability

It’s robust, cheap, and works on embedded targets.

---

If you want, I’ll write a compact C# (or C/ESP32) implementation of:

* IOI normalization
* weighted histogram
* PLL tracker
  in one go, tuned to your expected BPM range and latency.
